<!DOCTYPE html>
<html>
    <head>
        <link rel="icon" href="favicon.ico" type="image/x-icon">
        <link type="application/atom+xml" rel="alternate" href="http://ivandemarino.me/atom.xml" title="Too much coffee, too little time" />

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

        <!-- Third Party CSS -->
        <link href="/css/thirdparty/purecss-combo.min.css" rel="stylesheet">
        <link href="/css/thirdparty/font-awesome/css/font-awesome.min.css" rel="stylesheet">
        <!--[if IE 7]>
            <link href="/css/thirdparty/font-awesome/css/font-awesome-ie7.min.css" rel="stylesheet" >
        <![endif]-->

        <!-- Theme CSS -->
        <link rel="stylesheet" href="/css/leo.css">

        <!-- Utility JS -->
        <script type="text/javascript" src="/js/normalize.js"></script>

        
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-K0JQTBH0J9"></script>
            <script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());

              gtag('config', 'G-K0JQTBH0J9');
            </script>
        

        <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Money change problem: Greedy vs. Dyn.Pro. | Too much coffee, too little time</title>
<meta name="generator" content="Jekyll v4.3.1" />
<meta property="og:title" content="Money change problem: Greedy vs. Dyn.Pro." />
<meta name="author" content="detro" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This is a classical problem of Computer Science: it’s used to study both Greedy and Dynamic Programming algorithmic techniques. I hate having my pocket full of copper!!! -_- Definition Given: A set of n Denominations D[0...n-1] in ascending order, representing a Monetary Coin System An money amount A, as input calculate a solution: S[0...n-1], with 0 &lt;= S[i] &lt;= (A/S[i]) and 0 &lt; i &lt; n-1 where: A = Sum[i=0 -&gt; n-1] { D[i] * S[i] } Min{ Sum[i=0 -&gt; n-1] { S[i] } } In other words Find the smallest amount of coins to make the given amount. First, the Greedy solution The Greedy approach is as expected: tries to take as much largest coins as possible. Nothing fancy. [soucecode:c] change_coins_greedy(D[], A): init S[n] i = n-1 // Pick as much largest coins as possible while ( A &gt; 0 ) do: S[i] = A / D[i] A = A - S[i] * D[i] i = i - 1 endwhile // Set to ‘0’ the result for all the other coins while ( i &gt;= 0 ) do: S[i] = 0 i = i - 1 endwhile ``` This algorithm, of time complexity O(A), doesn’t work for some (rare) situations. When Greedy is not enough The Greedy algorithm doesn’t work for Denominations where if 2 denominations D[i] and D[j] exists with: i &lt; j D[i] &lt; D[j] 2 * D[i] &gt; D[j] For example, taken D = {1, 10, 30, 40} and amount A = 63, the Greedy algorithm will build a solution S = {3, 2, 0, 1}, that is sub-optimal. The optimal solution in this case is S = {3, 0, 2, 0}. UPDATE: In the comments Vincenzo gives an example where this condition doesn’t still stand but the Greedy Algorithm still produces the best solution. Dynamically Programmed Solution In real life the Greedy algorithm should be always enough: I couldn’t find any money system that has the problem described above. And, indeed, the Greedy approach is what every human being “normally” applies when changing money. But we are Comp-Sci, and we need to find a better solution ;-) - a Dynamically Programmed one. Given the function M[j], that is the minimum number of coins to make the amount ‘j’, it looks like: M[A] = min[i = 0 -&gt; n-1] { M[ A - D[i] ] +1 , M[A] } Here is the code:" />
<meta property="og:description" content="This is a classical problem of Computer Science: it’s used to study both Greedy and Dynamic Programming algorithmic techniques. I hate having my pocket full of copper!!! -_- Definition Given: A set of n Denominations D[0...n-1] in ascending order, representing a Monetary Coin System An money amount A, as input calculate a solution: S[0...n-1], with 0 &lt;= S[i] &lt;= (A/S[i]) and 0 &lt; i &lt; n-1 where: A = Sum[i=0 -&gt; n-1] { D[i] * S[i] } Min{ Sum[i=0 -&gt; n-1] { S[i] } } In other words Find the smallest amount of coins to make the given amount. First, the Greedy solution The Greedy approach is as expected: tries to take as much largest coins as possible. Nothing fancy. [soucecode:c] change_coins_greedy(D[], A): init S[n] i = n-1 // Pick as much largest coins as possible while ( A &gt; 0 ) do: S[i] = A / D[i] A = A - S[i] * D[i] i = i - 1 endwhile // Set to ‘0’ the result for all the other coins while ( i &gt;= 0 ) do: S[i] = 0 i = i - 1 endwhile ``` This algorithm, of time complexity O(A), doesn’t work for some (rare) situations. When Greedy is not enough The Greedy algorithm doesn’t work for Denominations where if 2 denominations D[i] and D[j] exists with: i &lt; j D[i] &lt; D[j] 2 * D[i] &gt; D[j] For example, taken D = {1, 10, 30, 40} and amount A = 63, the Greedy algorithm will build a solution S = {3, 2, 0, 1}, that is sub-optimal. The optimal solution in this case is S = {3, 0, 2, 0}. UPDATE: In the comments Vincenzo gives an example where this condition doesn’t still stand but the Greedy Algorithm still produces the best solution. Dynamically Programmed Solution In real life the Greedy algorithm should be always enough: I couldn’t find any money system that has the problem described above. And, indeed, the Greedy approach is what every human being “normally” applies when changing money. But we are Comp-Sci, and we need to find a better solution ;-) - a Dynamically Programmed one. Given the function M[j], that is the minimum number of coins to make the amount ‘j’, it looks like: M[A] = min[i = 0 -&gt; n-1] { M[ A - D[i] ] +1 , M[A] } Here is the code:" />
<link rel="canonical" href="http://ivandemarino.me/2010/01/17/money-change-problem-greedy-vs-dyn-pro/" />
<meta property="og:url" content="http://ivandemarino.me/2010/01/17/money-change-problem-greedy-vs-dyn-pro/" />
<meta property="og:site_name" content="Too much coffee, too little time" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2010-01-17T21:37:56+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Money change problem: Greedy vs. Dyn.Pro." />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"detro"},"dateModified":"2010-01-17T21:37:56+00:00","datePublished":"2010-01-17T21:37:56+00:00","description":"This is a classical problem of Computer Science: it’s used to study both Greedy and Dynamic Programming algorithmic techniques. I hate having my pocket full of copper!!! -_- Definition Given: A set of n Denominations D[0...n-1] in ascending order, representing a Monetary Coin System An money amount A, as input calculate a solution: S[0...n-1], with 0 &lt;= S[i] &lt;= (A/S[i]) and 0 &lt; i &lt; n-1 where: A = Sum[i=0 -&gt; n-1] { D[i] * S[i] } Min{ Sum[i=0 -&gt; n-1] { S[i] } } In other words Find the smallest amount of coins to make the given amount. First, the Greedy solution The Greedy approach is as expected: tries to take as much largest coins as possible. Nothing fancy. [soucecode:c] change_coins_greedy(D[], A): init S[n] i = n-1 // Pick as much largest coins as possible while ( A &gt; 0 ) do: S[i] = A / D[i] A = A - S[i] * D[i] i = i - 1 endwhile // Set to ‘0’ the result for all the other coins while ( i &gt;= 0 ) do: S[i] = 0 i = i - 1 endwhile ``` This algorithm, of time complexity O(A), doesn’t work for some (rare) situations. When Greedy is not enough The Greedy algorithm doesn’t work for Denominations where if 2 denominations D[i] and D[j] exists with: i &lt; j D[i] &lt; D[j] 2 * D[i] &gt; D[j] For example, taken D = {1, 10, 30, 40} and amount A = 63, the Greedy algorithm will build a solution S = {3, 2, 0, 1}, that is sub-optimal. The optimal solution in this case is S = {3, 0, 2, 0}. UPDATE: In the comments Vincenzo gives an example where this condition doesn’t still stand but the Greedy Algorithm still produces the best solution. Dynamically Programmed Solution In real life the Greedy algorithm should be always enough: I couldn’t find any money system that has the problem described above. And, indeed, the Greedy approach is what every human being “normally” applies when changing money. But we are Comp-Sci, and we need to find a better solution ;-) - a Dynamically Programmed one. Given the function M[j], that is the minimum number of coins to make the amount ‘j’, it looks like: M[A] = min[i = 0 -&gt; n-1] { M[ A - D[i] ] +1 , M[A] } Here is the code:","headline":"Money change problem: Greedy vs. Dyn.Pro.","mainEntityOfPage":{"@type":"WebPage","@id":"http://ivandemarino.me/2010/01/17/money-change-problem-greedy-vs-dyn-pro/"},"url":"http://ivandemarino.me/2010/01/17/money-change-problem-greedy-vs-dyn-pro/"}</script>
<!-- End Jekyll SEO tag -->

    </head>

    <body>
        <div id="layout" class="pure-g-r">

            <div id="sidebar" class="pure-u">
                <a id="toggle-navigation" href="#"><i class="icon-reorder"></i></a>

                <header id="header">

                    <hgroup>
                        <h1><a href="http://ivandemarino.me/">Too much <strong>coffee</strong><br/>too little <strong>time</strong></a></h1>
                        <h2>Ivan <strong>De Marino</strong></h2>
                    </hgroup>

                    <nav id="navigation">
                        
                            <ul id="internal-links">
                                
                                    <li class=""><a href="http://ivandemarino.me/">blog</a></li>
                                
                                    <li class=""><a href="http://ivandemarino.me/projects">projects</a></li>
                                
                                    <li class=""><a href="http://ivandemarino.me/about-me">about me</a></li>
                                
                                    <li class=""><a href="http://ivandemarino.me/archive">archive</a></li>
                                
                            </ul>
                        

                        
                            <ul id="rel-me-links">
                                
                                    <li><a rel="me" href="https://twitter.com/detronizator" target="_blank"><i class="icon-twitter"></i></a></li>
                                
                                    <li><a rel="me" href="https://github.com/detro" target="_blank"><i class="icon-github"></i></a></li>
                                
                                    <li><a rel="me" href="http://linkedin.com/in/ivandemarino" target="_blank"><i class="icon-linkedin"></i></a></li>
                                
                                    <li><a rel="me" href="http://ivandemarino.me/atom.xml" target="_blank"><i class="icon-rss"></i></a></li>
                                
                                    <li><a rel="me" href="http://ivandemarino.me/sitemap.xml" target="_blank"><i class="icon-sitemap"></i></a></li>
                                
                            </ul>
                        
                    </nav>

                </header>
            </div>

            <div id="main" class="pure-u-1">

                <div id="content">
                    
<article class="entry full pure-u-1">
    <header>
        <h1 class="title">
            
                Money change problem: Greedy vs. Dyn.Pro.
            
        </h1>
        
            <ul class="meta">
                
                    <li>
                        <i class="icon-calendar"></i>
                        <time datetime="2010-01-17">Sunday, 17 Jan 2010</time>
                    </li>
                

                
                    <li>
                        <i class="icon-tags"></i>
                        code &bull; personal &bull; money &bull; it &bull; greedy &bull; solution &bull; dynamic-programming &bull; english &bull; problem &bull; coin &bull; change &bull; cool
                    </li>
                

                
                    <li>
                        <i class="icon-time"></i>
                        690 words
                    </li>
                
            </ul>
        
    </header>
    
        <div class="body">
            
                <p>This is a classical problem of <a href="http://en.wikipedia.org/wiki/Computer_science">Computer Science</a>: it’s used to study both <a href="http://en.wikipedia.org/wiki/Greedy_algorithm">Greedy</a> and <a href="http://en.wikipedia.org/wiki/Dynamic_programming">Dynamic Programming</a> algorithmic techniques.</p>

<div class="img">
<img src="http://www.freephotosbank.com/photographers/photos1/45/med_53ff4957d796d0ff0a7d3151ec4e4a20.jpg" alt="Coins" />
I hate having my pocket full of copper!!! -_-
</div>

<h2 id="definition">Definition</h2>
<p>Given:</p>
<ul>
<li>A set of <code>n</code> Denominations <code>D[0...n-1]</code> in ascending order, representing a Monetary Coin System</li>
<li>An money amount <code>A</code>, as input</li>
</ul>
<p>calculate a solution:</p>
<ul>
	<li><strong><code>S[0...n-1]</code></strong>, with <code>0 &lt;= S[i] &lt;= (A/S[i])</code> and <code>0 &lt; i &lt; n-1</code></li>
</ul>
<p>where:</p>
<ul>
	<li><strong><code>A = Sum<sub>[i=0 -&gt; n-1]</sub> { D[i] * S[i] }</code></strong></li>
	<li><strong><code>Min{ Sum<sub>[i=0 -&gt; n-1]</sub> { S[i] } }</code></strong></li>
</ul>

<h2 id="in-other-words">In other words</h2>
<p>Find the smallest amount of coins to make the given amount.</p>

<h2 id="first-the-greedy-solution">First, the Greedy solution</h2>
<p>The Greedy approach is as expected: tries to take as much largest coins as possible. Nothing fancy.
[soucecode:c]
change_coins_greedy(D[], A):
   init S[n]
   i = n-1
   // Pick as much largest coins as possible
   while ( A &gt; 0 ) do:
      S[i] = A / D[i]
      A = A - S[i] * D[i]
      i = i - 1
   endwhile</p>

<p>// Set to ‘0’ the result for all the other coins
   while ( i &gt;= 0 ) do:
      S[i] = 0
      i = i - 1
   endwhile</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
This algorithm, of time complexity &lt;strong&gt;O(A)&lt;/strong&gt;, doesn't work for some (rare) situations.

## When Greedy is not enough
&lt;del datetime="2010-01-18T10:41:49+00:00"&gt;The Greedy algorithm doesn't work for Denominations where if &lt;strong&gt;2 denominations D[i] and D[j] exists&lt;/strong&gt; with:&lt;/del&gt;
&lt;ul&gt;
&lt;li&gt;&lt;del datetime="2010-01-18T10:41:49+00:00"&gt;&lt;strong&gt;i &amp;lt; j&lt;/strong&gt;&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del datetime="2010-01-18T10:41:49+00:00"&gt;&lt;strong&gt;D[i] &amp;lt; D[j]&lt;/strong&gt;&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del datetime="2010-01-18T10:41:49+00:00"&gt;&lt;strong&gt;2 * D[i] &amp;gt; D[j]&lt;/strong&gt;&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;del datetime="2010-01-18T10:41:49+00:00"&gt;For example, taken &lt;strong&gt;D = {1, 10, 30, 40}&lt;/strong&gt; and amount &lt;strong&gt;A = 63&lt;/strong&gt;, the Greedy algorithm will build a solution &lt;strong&gt;S = {3, 2, 0, 1}&lt;/strong&gt;, that is sub-optimal. The optimal solution in this case is &lt;strong&gt;S = {3, 0, 2, 0}&lt;/strong&gt;.&lt;/del&gt;
&lt;strong&gt;UPDATE:&lt;/strong&gt; &lt;a href="#comment-11505"&gt;In the comments Vincenzo&lt;/a&gt; gives an example where this condition doesn't still stand but the Greedy Algorithm still produces the best solution.

## Dynamically Programmed Solution
In real life the Greedy algorithm should be always enough: I couldn't find any money system that has the problem described above. And, indeed, the Greedy approach is what every human being "normally" applies when changing money.

But we are Comp-Sci, and we need to find a better solution ;-) - a Dynamically Programmed one.

Given the function &lt;strong&gt;M[j], that is the minimum number of coins to make the amount 'j'&lt;/strong&gt;, it looks like:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;M[A] = min&lt;sub&gt;[i = 0 -&gt; n-1]&lt;/sub&gt; { M[ A - D[i] ] +1 , M[A] }&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
Here is the code:

```c
unsigned int* change_coins_dynpro(unsigned short int D[],
    unsigned int D_size, unsigned int amount) {
    // Min. num. of coins for the given 'amount'
    unsigned int min_num_coins[amount], cur_min_num_coins;
    // Biggest coin used for the given 'amount'
    unsigned int biggest_coin_at[amount], cur_biggest_coin_at;
    
    unsigned int i, j;
    unsigned int* solution = NULL;
    
    // Ensure the Denomination System can represent any value
    if ( D[0] != 1 ) return NULL;
    
    // Initialize the solution array to Zero
    solution = (unsigned int*)calloc(D_size, sizeof(unsigned int));
    if ( NULL == solution ) {
        return NULL;
    }

    // Amount '0' requires '0' coins
    min_num_coins[0] = 0;
    biggest_coin_at[0] = 0;
    
    // For Amounts from '1' to 'amount'
    for ( i = 1; i &lt;= amount; ++i ) {
        // Start taking 'D[0]' 'i-times'
        cur_min_num_coins = (i / D[0]);
        cur_biggest_coin_at = 0;

        // For coins from 'D[1]' to 'D[D_size -1]'
        for ( j = 1; j &lt; D_size; ++j ) {
            // If 'D[j]' minimizes the num. of coins to take for amount 'i'
            if ( (i &gt;= D[j]) &amp;&amp; (cur_min_num_coins &gt;= (min_num_coins[ i - D[j] ] +1)) ) {
                cur_min_num_coins = min_num_coins[ i - D[j] ] +1;
                cur_biggest_coin_at = j;
            }
        }
        
        // Store the minimum just found
        min_num_coins[i] = cur_min_num_coins;
        biggest_coin_at[i] = cur_biggest_coin_at;
    }
    
    // Let's build the solution array
    while ( amount &gt; 0 ) {
        cur_biggest_coin_at = biggest_coin_at[amount];
        
        solution[ cur_biggest_coin_at ] += 1; // Add '1' of this coin to the solution
        amount -= D[cur_biggest_coin_at]; // Amount left when picking this coin
    }
    
    return solution;
}
</code></pre></div></div>

<p>Time complexity for this algorithm is <strong>O( Amount * num_of_denominations )</strong>.
<em>Pretty heavy algorithm, but do you want to compare with the satisfaction of carrying the minimum amount of coins with you? :P</em></p>

            
        </div>
    
</article>


                </div>

                <footer id="footer">
                    
                        <span>Hosted on <a href="http://pages.github.com/" target="_blank">GitHub Pages</a></span>
                    
                    
                        <span>Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a></span>
                    
                    
                    
                        <span>Licensed under <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">CC BY 4.0</a></span>
                    
                </footer>

            </div>
        </div>

        <script>
            // Registering "click" handler for "#toggle-navigation"
            normalize.elementAddEventListener(document.getElementById("toggle-navigation"),
                "click",
                function(e) {
                    var navEl = document.getElementById("navigation");
                    navEl.classList.toggle("open");
                    e.preventDefault();
                });
        </script>
    </body>
</html>
