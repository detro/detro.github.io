<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Largest square array of same integers</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/">Your New Jekyll Site</a></h1>
              <a class="extra" href="/">home</a>
            </div>

                <h2>Largest square array of same integers</h2>
<p class="meta">07 Jan 2010</p>

<div class="post">
<p>Tonight it&#39;s a challenging one. Or, better, a problem of which is really difficult to find a good solution in <strong>&lt; O(n<sup>3</sup>)</strong>. Indeed, it&#39;s a question that an ex-colleague was asked during an interview with <a href="http://www.google.com">Big-G</a>.</p>

<p><em>The guy, a part from being a REALLY smart guy, is also very humble, and he doesn&#39;t want to be mentioned by name. So, sorry for girls looking for a young, smart, promising young man: you need to find who he is yourself. ;)</em></p>

<h2>Problem Definition</h2>

<blockquote>
Given a 2D array (not necessarily square) of integers 1-9 :
[sourcecode:c]
{
 { 8 8 8 8 8 },
 { 8 8 8 8 8 },
 { 8 8 3 8 8 },
 { 8 8 8 5 5 },
 { 8 8 8 5 5 }
}
[/sourcecode]

Return:
<ol>
<li>The dimension of the largest square consisting of the same integer (in this case 2 because the largest is 2x2 square of 8s).</li>
<li>The integer which appears in that square (in this case 8)</li>
<li>The indices of the top left corner of the square (this this case (0,0) )</li>
<li>If there are multiple squares of the same dimension, you have to return the first one (i.e. the 8 one, not 5).</li>
</ol>
</blockquote>

<h2>My solution</h2>

<p>I designed this algorithm on my way back from my previous trip to Paris. Was at least 2 months I had it in my head, but there was the only empty slot of time where I could sit, think and code... on a spare piece of paper. And, still, it performs a disappointing Time Complexity of <strong>O(n<sup>3</sup>)</strong>.</p>

<p>It works like this:
[sourcecode:c]
init &quot;largest matrix&quot; to NULL/NONE/-1</p>

<p>for i = 0 to num<em>of</em>rows:
   for j = 0 to num<em>of</em>cols:
      calculates &quot;how big is the matrix that has TOP-LEFT corner in array[i][j]&quot;
      if &quot;what found is bigger then what found so far&quot;:
         save what found as &quot;the new largest matrix&quot;
[/sourcecode]</p>

<h3>Calculate how big is the matrix that has TOP-LEFT corner in array[i][j]</h3>

<p>It&#39;s a scanning that goes &quot;around&quot; the currently calculated matrix from TOP-RIGHT to BOTTOM-LEFT, moving CLOCKWISE. It starts from a base matrix, the single element in TOP-LEFT position, and grows until finds a different value. Sorry, no rocket science here. Probably only the way I manipulate the indexes could be seen as smart.</p>

<p>In the case of the input given above, the steps that it will do for cell <code>[0, 0]</code> will be like:</p>

<p><strong>STEP 1</strong>
[sourcecode:c]
{
 { 8 - - - - },
 { - - - - - },
 { - - - - - },
 { - - - - - },
 { - - - - - },
}
[/sourcecode]</p>

<p><strong>STEP 2</strong>
[sourcecode:c]
{
 { 8 8 - - - },
 { 8 8 - - - },
 { - - - - - },
 { - - - - - },
 { - - - - - },
}
[/sourcecode]</p>

<p><strong>STEP 3</strong>
[sourcecode:c]
{
 { 8 8 8 - - },
 { 8 8 8 - - },
 { - - 3 - - },
 { - - - - - },
 { - - - - - },
}
[/sourcecode]
<strong>Once the <code>&#39;3&#39;</code> is found, the search will stop, returning a <code>result = 2</code> (the measure of the diagonal of the found matrix).</strong></p>

<h2>A little trick to save us some time</h2>

<p>One thing I added to make things slightly better, is to check if <em>&quot;it&#39;s worth the effort&quot;</em>!
Given the current location in the matrix <code>[x, y]</code>, if the maximum diagonal that we COULD calculate if the rest of the elements were equal to what&#39;s in <code>[x, y]</code> is:
<ul>
<li>either smaller than the current maximum</li>
<li>or just equal to <code>&#39;1&#39;</code></li>
</ul>
then we jump any calculation and move to the next element in the matrix.</p>

<h2>The code</h2>

<p>[sourcecode:c]</p>

<h1>include <stdlib.h></h1>

<h1>include <stdio.h></h1>

<p>unsigned int measure<em>diagonal(
        // Need to treet the matrix as an mono-dimensinal array
        const unsigned int* matrix,
        const unsigned int rows,
        const unsigned int cols,
        const unsigned int x,
        const unsigned int y) {
    static unsigned int diagonal;
    static int curr</em>x; // I can&#39;t use unsigned because I need to detect &quot;out of bound&quot;
    static int curr_y;</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">#ifdef DEBUG
    printf(&quot;Measure the Diagonal from cell: (%d, %d)\n&quot;, x, y);
    printf(&quot;Matrix size: (%d, %d)\n&quot;, cols, rows);
#endif

// Base value: diagonal = 1 - matrix of 1 element
diagonal = 1;

// Now we are going to scan &quot;around&quot; the right and bottom borders
//  of the inner matrix ALREADY discovered.
//  The starting point is the element in position [x,y]
while ( 1 ) {
    #ifdef DEBUG
        printf(&quot;Current Diagonal for (%d,%d): %d\n&quot;, x, y, diagonal);
    #endif
    // If the area we are going to scan is outside the main matrix boundaries...
    if ( (x + diagonal) &gt;= cols || (y + diagonal) &gt;= rows ) {
        //... return the current diagonal as it is
        return diagonal;
    }

    curr_x = x + diagonal;
    curr_y = y;
    #ifdef DEBUG
        printf(&quot;curr_x(%d), curr_y(%d)\n&quot;, curr_x, curr_y);
    #endif

    do {
        #ifdef DEBUG
            printf(&quot;Comparing (%d, %d) with curr(%d, %d)\n&quot;, x,y, curr_x, curr_y);
        #endif
        // Check current element is equal to the Top-Left corner one
        if ( matrix[y * cols + x] != matrix[curr_y * cols + curr_x] ) {
            #ifdef DEBUG
                printf(&quot;Diagonal for cell(%d, %d) is: %d\n&quot;, x, y, diagonal);
            #endif
            // If not, the diagonal calculated so far is the diagonal
            return diagonal;
        }

        // Determine what&#39;s next
        if ( curr_y &lt; (y + diagonal) ) {
            // Move one row down in the matrix
            ++curr_y;
        } else {
            // Move one column left in the matrix
            --curr_x;
        }
    } while( (int)x &lt;= curr_x ); // Until within the boundaries

    // Good! We discovered an even larger matrix
    ++diagonal;
}
</code></pre></div>
<p>}</p>

<p>void calculate(const unsigned int* altitude_map,
        const unsigned int rows,
        const unsigned int cols) {</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">int best_number = -1;
int best_dimension = -1;
int best_row = -1;
int best_col = -1;
int r, c;
int temp_dimension = -1;

for (r = 0; r &lt; rows-1; r++) { // Avoid last row: would be 1 anyway
    for (c = 0; c &lt; cols-1; c++) { // Avoid last column: would be 1 anyway
        if ( temp_dimension &lt;= (int)(cols-c) &amp;&amp; temp_dimension &lt;= (int)(rows-r) ) {
            // Measure the diagonal of the matrix starting at position [r, c]
            temp_dimension = measure_diagonal(altitude_map, rows, cols, c, r);

            // Is it better then what we found so far?
            if (temp_dimension &gt; best_dimension) {
                best_dimension = temp_dimension;
                best_col = c;
                best_row = r;
                best_number = altitude_map[r * cols + c];
            }
        }
        #ifdef DEBUG
            else {
                printf(&quot;Skipped useless calculation at (%d, %d)\n&quot;, c, r);
            }
        #endif
    }
}

printf(&quot;ACTUAL   : contains a %dx%d grid of %ds at (%d , %d)\n&quot;,
    best_dimension, best_dimension, best_number, best_row, best_col);
</code></pre></div>
<p>}
[/sourcecode]</p>

<h2>Conclusions</h2>

<p>I&#39;m 100% sure that there are better solution, and indeed the guy above just sent me an alternative that <strong>he claims ( :-P ) has quadratic time complexity</strong>. I didn&#39;t check it out yet, but I&#39;ll post again if it&#39;s true (and, knowing the guy, it&#39;s highly probable).</p>

<p>In the meantime, if you have any comment or improvement, please speak up!</p>

</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/yourusername/">github.com/yourusername</a><br />
                  <a href="http://twitter.com/yourusername/">twitter.com/yourusername</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
