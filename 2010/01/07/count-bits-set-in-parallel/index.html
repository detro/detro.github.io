<!DOCTYPE html>
<html>
    <head>
        <link rel="icon" href="favicon.ico" type="image/x-icon">
        <link type="application/atom+xml" rel="alternate" href="http://ivandemarino.me/atom.xml" title="Too much coffee, too little time" />

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

        <!-- Third Party CSS -->
        <link href="/css/thirdparty/purecss-combo.min.css" rel="stylesheet">
        <link href="/css/thirdparty/font-awesome/css/font-awesome.min.css" rel="stylesheet">
        <!--[if IE 7]>
            <link href="/css/thirdparty/font-awesome/css/font-awesome-ie7.min.css" rel="stylesheet" >
        <![endif]-->

        <!-- Theme CSS -->
        <link rel="stylesheet" href="/css/leo.css">

        <!-- Utility JS -->
        <script type="text/javascript" src="/js/normalize.js"></script>

        
            <script async src="https://www.googletagmanager.com/gtag/js?id=UA-136869-11"></script>
            <script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());

              gtag('config', 'UA-136869-11');
            </script>
        

        
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-K0JQTBH0J9"></script>
            <script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());

              gtag('config', 'G-K0JQTBH0J9');
            </script>
        

        <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Count bits set in parallel | Too much coffee, too little time</title>
<meta name="generator" content="Jekyll v4.3.1" />
<meta property="og:title" content="Count bits set in parallel" />
<meta name="author" content="detro" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This time it’s not something I make myself. Indeed, I still can’t “see” it 100%: I got it, but it’s a bit complex. A cute little lady counting (bits? ;-) ) It’s a method to count the number of bits in a number in O(1), in just 5 lines of code. INHUMAN. The “human” solutions Of course, there are methods that look way more easy and, given that the size of a number in memory is “fixed”, the O(1) still stands. For example: 0. Based on the “evenness/oddness” of the number" />
<meta property="og:description" content="This time it’s not something I make myself. Indeed, I still can’t “see” it 100%: I got it, but it’s a bit complex. A cute little lady counting (bits? ;-) ) It’s a method to count the number of bits in a number in O(1), in just 5 lines of code. INHUMAN. The “human” solutions Of course, there are methods that look way more easy and, given that the size of a number in memory is “fixed”, the O(1) still stands. For example: 0. Based on the “evenness/oddness” of the number" />
<link rel="canonical" href="http://ivandemarino.me/2010/01/07/count-bits-set-in-parallel/" />
<meta property="og:url" content="http://ivandemarino.me/2010/01/07/count-bits-set-in-parallel/" />
<meta property="og:site_name" content="Too much coffee, too little time" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2010-01-07T13:33:46+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Count bits set in parallel" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"detro"},"dateModified":"2010-01-07T13:33:46+00:00","datePublished":"2010-01-07T13:33:46+00:00","description":"This time it’s not something I make myself. Indeed, I still can’t “see” it 100%: I got it, but it’s a bit complex. A cute little lady counting (bits? ;-) ) It’s a method to count the number of bits in a number in O(1), in just 5 lines of code. INHUMAN. The “human” solutions Of course, there are methods that look way more easy and, given that the size of a number in memory is “fixed”, the O(1) still stands. For example: 0. Based on the “evenness/oddness” of the number","headline":"Count bits set in parallel","mainEntityOfPage":{"@type":"WebPage","@id":"http://ivandemarino.me/2010/01/07/count-bits-set-in-parallel/"},"url":"http://ivandemarino.me/2010/01/07/count-bits-set-in-parallel/"}</script>
<!-- End Jekyll SEO tag -->

    </head>

    <body>
        <div id="layout" class="pure-g-r">

            <div id="sidebar" class="pure-u">
                <a id="toggle-navigation" href="#"><i class="icon-reorder"></i></a>

                <header id="header">

                    <hgroup>
                        <h1><a href="http://ivandemarino.me/">Too much <strong>coffee</strong><br/>too little <strong>time</strong></a></h1>
                        <h2>Ivan <strong>De Marino</strong></h2>
                    </hgroup>

                    <nav id="navigation">
                        
                            <ul id="internal-links">
                                
                                    <li class=""><a href="http://ivandemarino.me/">blog</a></li>
                                
                                    <li class=""><a href="http://ivandemarino.me/projects">projects</a></li>
                                
                                    <li class=""><a href="http://ivandemarino.me/about-me">about me</a></li>
                                
                                    <li class=""><a href="http://ivandemarino.me/archive">archive</a></li>
                                
                            </ul>
                        

                        
                            <ul id="rel-me-links">
                                
                                    <li><a rel="me" href="https://twitter.com/detronizator" target="_blank"><i class="icon-twitter"></i></a></li>
                                
                                    <li><a rel="me" href="https://github.com/detro" target="_blank"><i class="icon-github"></i></a></li>
                                
                                    <li><a rel="me" href="http://linkedin.com/in/ivandemarino" target="_blank"><i class="icon-linkedin"></i></a></li>
                                
                                    <li><a rel="me" href="http://ivandemarino.me/atom.xml" target="_blank"><i class="icon-rss"></i></a></li>
                                
                                    <li><a rel="me" href="http://ivandemarino.me/sitemap.xml" target="_blank"><i class="icon-sitemap"></i></a></li>
                                
                            </ul>
                        
                    </nav>

                </header>
            </div>

            <div id="main" class="pure-u-1">

                <div id="content">
                    
<article class="entry full pure-u-1">
    <header>
        <h1 class="title">
            
                Count bits set in parallel
            
        </h1>
        
            <ul class="meta">
                
                    <li>
                        <i class="icon-calendar"></i>
                        <time datetime="2010-01-07">Thursday, 07 Jan 2010</time>
                    </li>
                

                
                    <li>
                        <i class="icon-tags"></i>
                        count &bull; c &bull; code &bull; algorithm &bull; personal &bull; it &bull; english &bull; explaination &bull; bits &bull; cool
                    </li>
                

                
                    <li>
                        <i class="icon-time"></i>
                        1262 words
                    </li>
                
            </ul>
        
    </header>
    
        <div class="body">
            
                <p>This time it’s not something I make myself. Indeed, I still can’t “see” it 100%: I got it, but it’s a bit complex.</p>

<div class="img">
<img src="http://www.familyhelptree.com/blog/wp-content/uploads/2007/10/counting.jpg" alt="Counting kid" />
A cute little lady counting (bits? ;-) )
</div>

<p>It’s a method to count the number of bits in a number in O(1), in just 5 lines of code. <strong>INHUMAN.</strong></p>

<h2 id="the-human-solutions">The “human” solutions</h2>
<p>Of course, there are methods that look way more easy and, given that the size of a number in memory is “fixed”, the O(1) still stands. For example:
<strong>0. Based on the “evenness/oddness” of the number</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">bits_counter_v0</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">// If odd, add 1</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>1. Counting one bit at a time (always the least significant one)</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">bits_counter_v1</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">// If least-significant bit is 1, add 1</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>2. Counting 4 bit at a time with max 8 shifts, using an “hashmap” with precalculated results</strong>
The fact that it can count the bits in <em>“max 8 shifts”</em> has the trade off of the memory used by the hashmap.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">bits_counter_v2</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// "Hashmap" of the values for the least significant 4 bits</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">int_to_bits_count</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">0</span><span class="p">,</span> <span class="c1">// 0  00</span>
        <span class="mi">1</span><span class="p">,</span> <span class="c1">// 1  01</span>
        <span class="mi">1</span><span class="p">,</span> <span class="c1">// 2  10</span>
        <span class="mi">2</span><span class="p">,</span> <span class="c1">// 3  11</span>
        <span class="mi">1</span><span class="p">,</span> <span class="c1">// 4  100</span>
        <span class="mi">2</span><span class="p">,</span> <span class="c1">// 5  101</span>
        <span class="mi">2</span><span class="p">,</span> <span class="c1">// 6  110</span>
        <span class="mi">3</span><span class="p">,</span> <span class="c1">// 7  111</span>
        <span class="mi">1</span><span class="p">,</span> <span class="c1">// 8  1000</span>
        <span class="mi">2</span><span class="p">,</span> <span class="c1">// 9  1001</span>
        <span class="mi">2</span><span class="p">,</span> <span class="c1">// 10 1010</span>
        <span class="mi">3</span><span class="p">,</span> <span class="c1">// 11 1011</span>
        <span class="mi">2</span><span class="p">,</span> <span class="c1">// 12 1100</span>
        <span class="mi">3</span><span class="p">,</span> <span class="c1">// 13 1101</span>
        <span class="mi">3</span><span class="p">,</span> <span class="c1">// 14 1110</span>
        <span class="mi">4</span>  <span class="c1">// 15 1111</span>
    <span class="p">};</span>
    
    <span class="k">while</span> <span class="p">(</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Add the bits count of the least significant 4 bits</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="n">int_to_bits_count</span><span class="p">[</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">15</span> <span class="p">];</span>
        <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let’s see what some insane people made. <!--more--></p>

<h2 id="the-weird-solution">The “weird” solution</h2>
<p>This solution is not impressive, until you analyse how it does actually works, and think <em>“How the hell did they come out with this thing?”</em>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">bits_counter_v3</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// strip one set bit per iteration</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">&amp;=</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">result</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The explaination, from the <a href="http://bits.stephan-brumme.com/countBits.html">source where I took it</a> (thanks <a href="http://twitter.com/lucabox">Luca</a> for highlighting it to me):</p>
<blockquote>
The main trick, stripping a single bit with x &amp;= x − 1 (line 21), deserves some attention:
<ul>
<li>if x = 0, then the while-loop is not entered at all, so we do not need to consider this case</li>
<li>if the rightmost bit is 1, then the rightmost bit of x − 1 is 0. All other bits are identical and x &amp;= x − 1 → x = x − 1. Because all other bits are identical we stripped one set bit, the rightmost bit.</li>
<li>if the rightmost bits are 0, then x looks like this: ...1000. And x − 1 looks like this: ...0111. Result of x &amp;= x-1: ...0000.</li>
</ul>
Hence, x &amp;= x − 1 clears all bits except for the ones represented as dots, they remain the same. Again, exactly one bit was cleared.
In general, x &amp;= x − 1 always sets the rightmost bit which was 1 to 0.
</blockquote>

<p>I mean, method 0 and 1 above are practically doing the same thing. This one is just “weird”.</p>

<h2 id="the-inhuman-solution-counting-bits-set-in-parallel">The INHUMAN solution: Counting bits set in Parallel</h2>
<p><em>Ladies and Gentlemen</em>, the algorithm that is still making my mind go banana:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">bits_counter_v4</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// count bits of each 2-bit chunk</span>
    <span class="n">x</span>  <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="p">((</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x55555555</span><span class="p">);</span>
    <span class="c1">// count bits of each 4-bit chunk</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mh">0x33333333</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x33333333</span><span class="p">);</span>
    <span class="c1">// count bits of each 8-bit chunk</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
    <span class="c1">// mask out junk</span>
    <span class="n">x</span> <span class="o">&amp;=</span> <span class="mh">0xF0F0F0F</span><span class="p">;</span>
    <span class="c1">// add all four 8-bit chunks</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="mh">0x01010101</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Again, from the same source:</p>
<blockquote>
Counting all set bits of an integer was part of many mainframe CPU's assembler language but somehow
x86 CPUs ignored it for decades. Apparently Intel introduced the POPCNT opcode in its Core i7 design.

Meanwhile, the population count has to be implemented by other means.
The main observations lies in the fact that you can subdivide any bitblock into smaller chunks,
compute their population count and add all intermediate results.

First, the code counts the bits of two adjacent bits:


```c
0b and 0b &gt;&gt; 00b
0b and 1b &gt;&gt; 01b
1b and 0b &gt;&gt; 01b
1b and 1b &gt;&gt; 10b
```


The whole algorithm modifies the input in order to generate the output, that means it works in-place.
Line 3 performs the 2-bit count at once based on the observation:


```c
00b &gt;&gt; unchanged, still 00b
01b &gt;&gt; unchanged, still 01b
10b &gt;&gt; must be converted to 01b
11b &gt;&gt; must be converted to 10b
```


Whenever the higher bit of each 2-bit group is set, subtracting <code>01b</code> gives the desired outcome.
Looks like branching ... but as it turns out, the subtraction can be done always: just subtract the higher bit !
If it is <code>0</code>, the result remains unchanged, if it is <code>1</code>, then we get the right numbers, too.
The shift <code>x &gt;&gt; 1</code> and the following mask of all odd bits (<code>0x55</code> is <code>01010101b</code>):


```c
00b &gt;&gt; shifted: ?0b &gt;&gt; masked: 00b &gt;&gt; subtraction: 00b - 00b &gt;&gt; 00b
01b &gt;&gt; shifted: ?0b &gt;&gt; masked: 00b &gt;&gt; subtraction: 01b - 00b &gt;&gt; 01b
10b &gt;&gt; shifted: ?1b &gt;&gt; masked: 01b &gt;&gt; subtraction: 10b - 01b &gt;&gt; 01b
11b &gt;&gt; shifted: ?1b &gt;&gt; masked: 01b &gt;&gt; subtraction: 11b - 01b &gt;&gt; 10b
```


Now the 2-bit count is done. As you can see, there are just three possible decimal results: <code>0, 1 or 2</code>.

Then, two adjacent 2-bit groups are joined to 4-bit groups (line 5):


```c
00b and 00b &gt;&gt; 0000b
00b and 01b &gt;&gt; 0001b
00b and 10b &gt;&gt; 0010b
01b and 00b &gt;&gt; 0001b
01b and 01b &gt;&gt; 0010b
01b and 10b &gt;&gt; 0011b
10b and 00b &gt;&gt; 0010b
10b and 01b &gt;&gt; 0011b
10b and 10b &gt;&gt; 0100b
```


This time, the 2-bit groups are masked and shifted to match and then simply added. No overflow is possible.


```c
00b + 00b &gt;&gt; 0000b
00b + 01b &gt;&gt; 0001b
00b + 10b &gt;&gt; 0010b
01b + 00b &gt;&gt; 0001b
01b + 01b &gt;&gt; 0010b
01b + 10b &gt;&gt; 0011b
10b + 00b &gt;&gt; 0010b
10b + 01b &gt;&gt; 0011b
10b + 10b &gt;&gt; 0100b
```


The same procedure is done for all 4-bit groups yielding the bit counts for each of the four bytes (line 7)
in their lower four bits. That means, each byte contains its bit count, however, the upper four bits may
contain junk and are masked out (line 9).

Multiplying by <code>0x01010101</code> has an interesting property if we name the four bytes A, B, C, D:


```c
A, B, C, D &gt;&gt; A+B+C+D, B+C+D, C+D, D
```


Obviously the highest byte is what we are looking for. The right shift (line 11) returns just it.
</blockquote>

<p>Of course, this method has a big limitation: it works only with 32-bit numbers.
To use other sizes (64-bit) needs to be adapted. Still, it blows my mind.</p>

            
        </div>
    
</article>


                </div>

                <footer id="footer">
                    
                        <span>Hosted on <a href="http://pages.github.com/" target="_blank">GitHub Pages</a></span>
                    
                    
                        <span>Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a></span>
                    
                    
                    
                        <span>Licensed under <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">CC BY 4.0</a></span>
                    
                </footer>

            </div>
        </div>

        <script>
            // Registering "click" handler for "#toggle-navigation"
            normalize.elementAddEventListener(document.getElementById("toggle-navigation"),
                "click",
                function(e) {
                    var navEl = document.getElementById("navigation");
                    navEl.classList.toggle("open");
                    e.preventDefault();
                });
        </script>
    </body>
</html>
