<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Count bits set in parallel</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/">Considering yourself perfectible makes you perfect - Ivan De Marino</a></h1>
              <a class="extra" href="/">home</a>
            </div>

                <h2>Count bits set in parallel</h2>
<p class="meta">07 Jan 2010</p>

<div class="post">
<p>This time it&#39;s not something I make myself. Indeed, I still can&#39;t &quot;see&quot; it 100%: I got it, but it&#39;s a bit complex.</p>

<div class="img">
<img src="http://www.familyhelptree.com/blog/wp-content/uploads/2007/10/counting.jpg" alt="Counting kid" />
A cute little lady counting (bits? ;-) )
</div>

<p>It&#39;s a method to count the number of bits in a number in O(1), in just 5 lines of code. <strong>INHUMAN.</strong></p>

<h2>The &quot;human&quot; solutions</h2>

<p>Of course, there are methods that look way more easy and, given that the size of a number in memory is &quot;fixed&quot;, the O(1) still stands. For example:
<strong>0. Based on the &quot;evenness/oddness&quot; of the number</strong></p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">bits_counter_v0</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">// If odd, add 1</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>1. Counting one bit at a time (always the least significant one)</strong></p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">bits_counter_v1</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">// If least-significant bit is 1, add 1</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>2. Counting 4 bit at a time with max 8 shifts, using an &quot;hashmap&quot; with precalculated results</strong>
The fact that it can count the bits in <em>&quot;max 8 shifts&quot;</em> has the trade off of the memory used by the hashmap.</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">bits_counter_v2</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// &quot;Hashmap&quot; of the values for the least significant 4 bits</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">int_to_bits_count</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">0</span><span class="p">,</span> <span class="c1">// 0  00</span>
        <span class="mi">1</span><span class="p">,</span> <span class="c1">// 1  01</span>
        <span class="mi">1</span><span class="p">,</span> <span class="c1">// 2  10</span>
        <span class="mi">2</span><span class="p">,</span> <span class="c1">// 3  11</span>
        <span class="mi">1</span><span class="p">,</span> <span class="c1">// 4  100</span>
        <span class="mi">2</span><span class="p">,</span> <span class="c1">// 5  101</span>
        <span class="mi">2</span><span class="p">,</span> <span class="c1">// 6  110</span>
        <span class="mi">3</span><span class="p">,</span> <span class="c1">// 7  111</span>
        <span class="mi">1</span><span class="p">,</span> <span class="c1">// 8  1000</span>
        <span class="mi">2</span><span class="p">,</span> <span class="c1">// 9  1001</span>
        <span class="mi">2</span><span class="p">,</span> <span class="c1">// 10 1010</span>
        <span class="mi">3</span><span class="p">,</span> <span class="c1">// 11 1011</span>
        <span class="mi">2</span><span class="p">,</span> <span class="c1">// 12 1100</span>
        <span class="mi">3</span><span class="p">,</span> <span class="c1">// 13 1101</span>
        <span class="mi">3</span><span class="p">,</span> <span class="c1">// 14 1110</span>
        <span class="mi">4</span>  <span class="c1">// 15 1111</span>
    <span class="p">};</span>

    <span class="k">while</span> <span class="p">(</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Add the bits count of the least significant 4 bits</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="n">int_to_bits_count</span><span class="p">[</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mi">15</span> <span class="p">];</span>
        <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Let&#39;s see what some insane people made. &lt;!--more--&gt;</p>

<h2>The &quot;weird&quot; solution</h2>

<p>This solution is not impressive, until you analyse how it does actually works, and think <em>&quot;How the hell did they come out with this thing?&quot;</em>.</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">bits_counter_v3</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// strip one set bit per iteration</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">&amp;=</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">result</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>The explaination, from the <a href="http://bits.stephan-brumme.com/countBits.html">source where I took it</a> (thanks <a href="http://twitter.com/lucabox">Luca</a> for highlighting it to me):
<blockquote>
The main trick, stripping a single bit with x &amp;= x − 1 (line 21), deserves some attention:
<ul>
<li>if x = 0, then the while-loop is not entered at all, so we do not need to consider this case</li>
<li>if the rightmost bit is 1, then the rightmost bit of x − 1 is 0. All other bits are identical and x &amp;= x − 1 → x = x − 1. Because all other bits are identical we stripped one set bit, the rightmost bit.</li>
<li>if the rightmost bits are 0, then x looks like this: ...1000. And x − 1 looks like this: ...0111. Result of x &amp;= x-1: ...0000.</li>
</ul>
Hence, x &amp;= x − 1 clears all bits except for the ones represented as dots, they remain the same. Again, exactly one bit was cleared.
In general, x &amp;= x − 1 always sets the rightmost bit which was 1 to 0.
</blockquote></p>

<p>I mean, method 0 and 1 above are practically doing the same thing. This one is just &quot;weird&quot;.</p>

<h2>The INHUMAN solution: Counting bits set in Parallel</h2>

<p><em>Ladies and Gentlemen</em>, the algorithm that is still making my mind go banana:</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">bits_counter_v4</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// count bits of each 2-bit chunk</span>
    <span class="n">x</span>  <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="p">((</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x55555555</span><span class="p">);</span>
    <span class="c1">// count bits of each 4-bit chunk</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mh">0x33333333</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x33333333</span><span class="p">);</span>
    <span class="c1">// count bits of each 8-bit chunk</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
    <span class="c1">// mask out junk</span>
    <span class="n">x</span> <span class="o">&amp;=</span> <span class="mh">0xF0F0F0F</span><span class="p">;</span>
    <span class="c1">// add all four 8-bit chunks</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="mh">0x01010101</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Again, from the same source:
<blockquote>
Counting all set bits of an integer was part of many mainframe CPU&#39;s assembler language but somehow
x86 CPUs ignored it for decades. Apparently Intel introduced the POPCNT opcode in its Core i7 design.</p>

<p>Meanwhile, the population count has to be implemented by other means.
The main observations lies in the fact that you can subdivide any bitblock into smaller chunks,
compute their population count and add all intermediate results.</p>

<p>First, the code counts the bits of two adjacent bits:</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="mi">0</span><span class="n">b</span> <span class="n">and</span> <span class="mi">0</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mo">00</span><span class="n">b</span>
<span class="mi">0</span><span class="n">b</span> <span class="n">and</span> <span class="mi">1</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mo">01</span><span class="n">b</span>
<span class="mi">1</span><span class="n">b</span> <span class="n">and</span> <span class="mi">0</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mo">01</span><span class="n">b</span>
<span class="mi">1</span><span class="n">b</span> <span class="n">and</span> <span class="mi">1</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="n">b</span>
</code></pre></div>
<p>The whole algorithm modifies the input in order to generate the output, that means it works in-place.
Line 3 performs the 2-bit count at once based on the observation:</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="mo">00</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">unchanged</span><span class="p">,</span> <span class="n">still</span> <span class="mo">00</span><span class="n">b</span>
<span class="mo">01</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">unchanged</span><span class="p">,</span> <span class="n">still</span> <span class="mo">01</span><span class="n">b</span>
<span class="mi">10</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">must</span> <span class="n">be</span> <span class="n">converted</span> <span class="n">to</span> <span class="mo">01</span><span class="n">b</span>
<span class="mi">11</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">must</span> <span class="n">be</span> <span class="n">converted</span> <span class="n">to</span> <span class="mi">10</span><span class="n">b</span>
</code></pre></div>
<p>Whenever the higher bit of each 2-bit group is set, subtracting <code>01b</code> gives the desired outcome.
Looks like branching ... but as it turns out, the subtraction can be done always: just subtract the higher bit !
If it is <code>0</code>, the result remains unchanged, if it is <code>1</code>, then we get the right numbers, too.
The shift <code>x &gt;&gt; 1</code> and the following mask of all odd bits (<code>0x55</code> is <code>01010101b</code>):</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="mo">00</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">shifted</span><span class="o">:</span> <span class="o">?</span><span class="mi">0</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">masked</span><span class="o">:</span> <span class="mo">00</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">subtraction</span><span class="o">:</span> <span class="mo">00</span><span class="n">b</span> <span class="o">-</span> <span class="mo">00</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mo">00</span><span class="n">b</span>
<span class="mo">01</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">shifted</span><span class="o">:</span> <span class="o">?</span><span class="mi">0</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">masked</span><span class="o">:</span> <span class="mo">00</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">subtraction</span><span class="o">:</span> <span class="mo">01</span><span class="n">b</span> <span class="o">-</span> <span class="mo">00</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mo">01</span><span class="n">b</span>
<span class="mi">10</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">shifted</span><span class="o">:</span> <span class="o">?</span><span class="mi">1</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">masked</span><span class="o">:</span> <span class="mo">01</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">subtraction</span><span class="o">:</span> <span class="mi">10</span><span class="n">b</span> <span class="o">-</span> <span class="mo">01</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mo">01</span><span class="n">b</span>
<span class="mi">11</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">shifted</span><span class="o">:</span> <span class="o">?</span><span class="mi">1</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">masked</span><span class="o">:</span> <span class="mo">01</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">subtraction</span><span class="o">:</span> <span class="mi">11</span><span class="n">b</span> <span class="o">-</span> <span class="mo">01</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="n">b</span>
</code></pre></div>
<p>Now the 2-bit count is done. As you can see, there are just three possible decimal results: <code>0, 1 or 2</code>.</p>

<p>Then, two adjacent 2-bit groups are joined to 4-bit groups (line 5):</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="mo">00</span><span class="n">b</span> <span class="n">and</span> <span class="mo">00</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mo">0000</span><span class="n">b</span>
<span class="mo">00</span><span class="n">b</span> <span class="n">and</span> <span class="mo">01</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mo">0001</span><span class="n">b</span>
<span class="mo">00</span><span class="n">b</span> <span class="n">and</span> <span class="mi">10</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mo">0010</span><span class="n">b</span>
<span class="mo">01</span><span class="n">b</span> <span class="n">and</span> <span class="mo">00</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mo">0001</span><span class="n">b</span>
<span class="mo">01</span><span class="n">b</span> <span class="n">and</span> <span class="mo">01</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mo">0010</span><span class="n">b</span>
<span class="mo">01</span><span class="n">b</span> <span class="n">and</span> <span class="mi">10</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mo">0011</span><span class="n">b</span>
<span class="mi">10</span><span class="n">b</span> <span class="n">and</span> <span class="mo">00</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mo">0010</span><span class="n">b</span>
<span class="mi">10</span><span class="n">b</span> <span class="n">and</span> <span class="mo">01</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mo">0011</span><span class="n">b</span>
<span class="mi">10</span><span class="n">b</span> <span class="n">and</span> <span class="mi">10</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mo">0100</span><span class="n">b</span>
</code></pre></div>
<p>This time, the 2-bit groups are masked and shifted to match and then simply added. No overflow is possible.</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="mo">00</span><span class="n">b</span> <span class="o">+</span> <span class="mo">00</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mo">0000</span><span class="n">b</span>
<span class="mo">00</span><span class="n">b</span> <span class="o">+</span> <span class="mo">01</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mo">0001</span><span class="n">b</span>
<span class="mo">00</span><span class="n">b</span> <span class="o">+</span> <span class="mi">10</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mo">0010</span><span class="n">b</span>
<span class="mo">01</span><span class="n">b</span> <span class="o">+</span> <span class="mo">00</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mo">0001</span><span class="n">b</span>
<span class="mo">01</span><span class="n">b</span> <span class="o">+</span> <span class="mo">01</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mo">0010</span><span class="n">b</span>
<span class="mo">01</span><span class="n">b</span> <span class="o">+</span> <span class="mi">10</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mo">0011</span><span class="n">b</span>
<span class="mi">10</span><span class="n">b</span> <span class="o">+</span> <span class="mo">00</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mo">0010</span><span class="n">b</span>
<span class="mi">10</span><span class="n">b</span> <span class="o">+</span> <span class="mo">01</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mo">0011</span><span class="n">b</span>
<span class="mi">10</span><span class="n">b</span> <span class="o">+</span> <span class="mi">10</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mo">0100</span><span class="n">b</span>
</code></pre></div>
<p>The same procedure is done for all 4-bit groups yielding the bit counts for each of the four bytes (line 7)
in their lower four bits. That means, each byte contains its bit count, however, the upper four bits may
contain junk and are masked out (line 9).</p>

<p>Multiplying by <code>0x01010101</code> has an interesting property if we name the four bytes A, B, C, D:</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span> <span class="o">&gt;&gt;</span> <span class="n">A</span><span class="o">+</span><span class="n">B</span><span class="o">+</span><span class="n">C</span><span class="o">+</span><span class="n">D</span><span class="p">,</span> <span class="n">B</span><span class="o">+</span><span class="n">C</span><span class="o">+</span><span class="n">D</span><span class="p">,</span> <span class="n">C</span><span class="o">+</span><span class="n">D</span><span class="p">,</span> <span class="n">D</span>
</code></pre></div>
<p>Obviously the highest byte is what we are looking for. The right shift (line 11) returns just it.
</blockquote></p>

<p>Of course, this method has a big limitation: it works only with 32-bit numbers.
To use other sizes (64-bit) needs to be adapted. Still, it blows my mind.</p>

</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/yourusername/">github.com/yourusername</a><br />
                  <a href="http://twitter.com/yourusername/">twitter.com/yourusername</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
