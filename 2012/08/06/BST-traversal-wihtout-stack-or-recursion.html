<!DOCTYPE html>
<html>
    <head>
        <link rel="icon" href="/favicon.ico" type="image/x-icon">
        <link type="application/atom+xml" rel="alternate" href="https://ivandemarino.me/atom.xml" title="Too much coffee, too little time" />

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

        <!-- Third Party CSS -->
        <link href="/css/thirdparty/purecss-combo.min.css" rel="stylesheet">
        <link href="/css/thirdparty/font-awesome/css/font-awesome.min.css" rel="stylesheet">
        <!--[if IE 7]>
            <link href="/css/thirdparty/font-awesome/css/font-awesome-ie7.min.css" rel="stylesheet" >
        <![endif]-->

        <!-- Theme CSS -->
        <link rel="stylesheet" href="/css/leo.css">

        <!-- Utility JS -->
        <script type="text/javascript" src="/js/normalize.js"></script>

        
            <script async src="https://www.googletagmanager.com/gtag/js?id=UA-136869-11"></script>
            <script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());

              gtag('config', 'UA-136869-11');
            </script>
        

        
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-K0JQTBH0J9"></script>
            <script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());

              gtag('config', 'G-K0JQTBH0J9');
            </script>
        

        <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>BST traversal without stack or recursion (?) | Too much coffee, too little time</title>
<meta name="generator" content="Jekyll v4.3.1" />
<meta property="og:title" content="BST traversal without stack or recursion (?)" />
<meta name="author" content="detro" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="SPOILER: this article assumes quite a lot of things about your knowledge of binary trees and data structure. I won’t spend much time introducing concepts. Deal with it. Some time ago I had the pleasure to meet with Chris Lord, who introduced me to the concept of Binary Tree Traversal without using neither a stack/queue or recursion. The list of requirements that such algorithm has to fulfil: Constant Space: no extra data structure to do the traversal Non-destructive: once finished, the tree needs to be exactly how it was before the visit Sounded crazy initially, but than I looked into it more deeply and discovered, thanks to some pointers from Luca Colantonio, that there is an algorithm in literature that does just that: Morris In-Order Traversal. Morris does just that - and a very good description of how it works can be found on Stack Overflow. I suggest you have a good read and come back: pointless of me to repeat it here. … You back? Great! So, before “discovering” the Morris algorithm, I was trying to write a solution myself. My basic idea was to: Move downwards Manipulate pointers to the branch we are about to explore, to point backward so we have “a way back” Restore once done with that branch At that stage, it had not occur to me to try to manipulate the entire tree structure like Morris does: I wanted to be very subtle, with the data structure resembling the original tree (though, with backward pointers). The key issue I hit? Going Backward. Once I’m done visiting the branches of a node, I need to go back to the parent (to which I have a pointer too), and restore the structure. But HOW am I going to reconstruct the tree? How do I know if the Branch I just visited was the left or the right branch of the parent I want to move back to? Downsize the problem In a general Binary Tree, there is no guarantee of the order and distribution of nodes. It’s just a tree where every node has 0, 1 or 2 child nodes. I didn’t have any “rule” on which to build a backward-restoring logic. But then I had an idea: what about BSTs (Binary Search Tree)? In those trees, there is a strong order relationship between a node and its childs. This means that at any moment in time, once I’m done visiting a branch, I can reconstruct where I’m coming from, looking at the values of the parent and the child: parent-&gt;value &gt; child-&gt;value ? is_left_child : is_right_child And, so I wrote the De Marino BST Post-Order Traversal algorithm: void de_marino_bst_post_order_traversal(node *root) { node *curr = root; //&lt; current node node *par = NULL; //&lt; parent of current node node *next = root; //&lt; next node to traversal (but sometimes, just temp variable) int dir = DOWN; //&lt; direction in which we are moving do { if (dir == DOWN &amp;&amp; curr-&gt;left != NULL) { // Go down left next = curr-&gt;left; curr-&gt;left = par; par = curr; curr = next; } else if (dir == DOWN &amp;&amp; curr-&gt;right != NULL) { // Go down right next = curr-&gt;right; curr-&gt;right = par; par = curr; curr = next; } else { printf(&quot;%d\n&quot;, curr != NULL ? curr-&gt;value : -1); if (par-&gt;value &gt; curr-&gt;value &amp;&amp; par-&gt;right != NULL) { // Go down right, coming from left // NOTE: order gives us a hint about where we come from dir = DOWN; next = par-&gt;left; // hold the way back par-&gt;left = curr; curr = par-&gt;right; par-&gt;right = next; // store the way back in the right child of par now next = curr; } else { dir = UP; if (par-&gt;value &gt; curr-&gt;value) { // Go up, coming from left // NOTE: order gives us a hint about where we come from next = par-&gt;left; par-&gt;left = curr; } else { // Go up, coming from right // NOTE: order gives us a hint about where we come from next = par-&gt;right; par-&gt;right = curr; } curr = par; par = next; } } } while(next != NULL &amp;&amp; par != NULL); printf(&quot;%d\n&quot;, curr != NULL ? curr-&gt;value : -1); } Now, I’m almost 100% sure that I’m not the first one to stumble into something like this, but for now I’m unable to find anything in literature - cough … Google … cough . An advantage over Morris Yes, this algorithm requires the strong condition of BST while Morris works with any Binary Tree. That’s a given. But this algorithm is also faster: it doesn’t go deep into the tree to find the rightmost left child of a node, like Morris. From a quick look the computation is linear - O(n): every node is visited only once. But maybe I’m overlooking something in Morris. Far from perfect I’m also sure that this algorithm is far from bug-less: I have spent on it less than 24h between coding and thinking. So, please, to all the Computer Scientists people out there: let me know your thoughts and critics. This is a great way to spend some of that theory that we have in our heads. I have added this code to my coding exercises repo on GitHub, if you want to try it out (check latest commits). Now, as I expect, feel free to ignore my warnings and start your opinionated trashing - I’m pretty confident I’d deserve it. :)" />
<meta property="og:description" content="SPOILER: this article assumes quite a lot of things about your knowledge of binary trees and data structure. I won’t spend much time introducing concepts. Deal with it. Some time ago I had the pleasure to meet with Chris Lord, who introduced me to the concept of Binary Tree Traversal without using neither a stack/queue or recursion. The list of requirements that such algorithm has to fulfil: Constant Space: no extra data structure to do the traversal Non-destructive: once finished, the tree needs to be exactly how it was before the visit Sounded crazy initially, but than I looked into it more deeply and discovered, thanks to some pointers from Luca Colantonio, that there is an algorithm in literature that does just that: Morris In-Order Traversal. Morris does just that - and a very good description of how it works can be found on Stack Overflow. I suggest you have a good read and come back: pointless of me to repeat it here. … You back? Great! So, before “discovering” the Morris algorithm, I was trying to write a solution myself. My basic idea was to: Move downwards Manipulate pointers to the branch we are about to explore, to point backward so we have “a way back” Restore once done with that branch At that stage, it had not occur to me to try to manipulate the entire tree structure like Morris does: I wanted to be very subtle, with the data structure resembling the original tree (though, with backward pointers). The key issue I hit? Going Backward. Once I’m done visiting the branches of a node, I need to go back to the parent (to which I have a pointer too), and restore the structure. But HOW am I going to reconstruct the tree? How do I know if the Branch I just visited was the left or the right branch of the parent I want to move back to? Downsize the problem In a general Binary Tree, there is no guarantee of the order and distribution of nodes. It’s just a tree where every node has 0, 1 or 2 child nodes. I didn’t have any “rule” on which to build a backward-restoring logic. But then I had an idea: what about BSTs (Binary Search Tree)? In those trees, there is a strong order relationship between a node and its childs. This means that at any moment in time, once I’m done visiting a branch, I can reconstruct where I’m coming from, looking at the values of the parent and the child: parent-&gt;value &gt; child-&gt;value ? is_left_child : is_right_child And, so I wrote the De Marino BST Post-Order Traversal algorithm: void de_marino_bst_post_order_traversal(node *root) { node *curr = root; //&lt; current node node *par = NULL; //&lt; parent of current node node *next = root; //&lt; next node to traversal (but sometimes, just temp variable) int dir = DOWN; //&lt; direction in which we are moving do { if (dir == DOWN &amp;&amp; curr-&gt;left != NULL) { // Go down left next = curr-&gt;left; curr-&gt;left = par; par = curr; curr = next; } else if (dir == DOWN &amp;&amp; curr-&gt;right != NULL) { // Go down right next = curr-&gt;right; curr-&gt;right = par; par = curr; curr = next; } else { printf(&quot;%d\n&quot;, curr != NULL ? curr-&gt;value : -1); if (par-&gt;value &gt; curr-&gt;value &amp;&amp; par-&gt;right != NULL) { // Go down right, coming from left // NOTE: order gives us a hint about where we come from dir = DOWN; next = par-&gt;left; // hold the way back par-&gt;left = curr; curr = par-&gt;right; par-&gt;right = next; // store the way back in the right child of par now next = curr; } else { dir = UP; if (par-&gt;value &gt; curr-&gt;value) { // Go up, coming from left // NOTE: order gives us a hint about where we come from next = par-&gt;left; par-&gt;left = curr; } else { // Go up, coming from right // NOTE: order gives us a hint about where we come from next = par-&gt;right; par-&gt;right = curr; } curr = par; par = next; } } } while(next != NULL &amp;&amp; par != NULL); printf(&quot;%d\n&quot;, curr != NULL ? curr-&gt;value : -1); } Now, I’m almost 100% sure that I’m not the first one to stumble into something like this, but for now I’m unable to find anything in literature - cough … Google … cough . An advantage over Morris Yes, this algorithm requires the strong condition of BST while Morris works with any Binary Tree. That’s a given. But this algorithm is also faster: it doesn’t go deep into the tree to find the rightmost left child of a node, like Morris. From a quick look the computation is linear - O(n): every node is visited only once. But maybe I’m overlooking something in Morris. Far from perfect I’m also sure that this algorithm is far from bug-less: I have spent on it less than 24h between coding and thinking. So, please, to all the Computer Scientists people out there: let me know your thoughts and critics. This is a great way to spend some of that theory that we have in our heads. I have added this code to my coding exercises repo on GitHub, if you want to try it out (check latest commits). Now, as I expect, feel free to ignore my warnings and start your opinionated trashing - I’m pretty confident I’d deserve it. :)" />
<link rel="canonical" href="https://ivandemarino.me/2012/08/06/BST-traversal-wihtout-stack-or-recursion" />
<meta property="og:url" content="https://ivandemarino.me/2012/08/06/BST-traversal-wihtout-stack-or-recursion" />
<meta property="og:site_name" content="Too much coffee, too little time" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2012-08-06T12:47:17+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="BST traversal without stack or recursion (?)" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"detro"},"dateModified":"2012-08-06T12:47:17+01:00","datePublished":"2012-08-06T12:47:17+01:00","description":"SPOILER: this article assumes quite a lot of things about your knowledge of binary trees and data structure. I won’t spend much time introducing concepts. Deal with it. Some time ago I had the pleasure to meet with Chris Lord, who introduced me to the concept of Binary Tree Traversal without using neither a stack/queue or recursion. The list of requirements that such algorithm has to fulfil: Constant Space: no extra data structure to do the traversal Non-destructive: once finished, the tree needs to be exactly how it was before the visit Sounded crazy initially, but than I looked into it more deeply and discovered, thanks to some pointers from Luca Colantonio, that there is an algorithm in literature that does just that: Morris In-Order Traversal. Morris does just that - and a very good description of how it works can be found on Stack Overflow. I suggest you have a good read and come back: pointless of me to repeat it here. … You back? Great! So, before “discovering” the Morris algorithm, I was trying to write a solution myself. My basic idea was to: Move downwards Manipulate pointers to the branch we are about to explore, to point backward so we have “a way back” Restore once done with that branch At that stage, it had not occur to me to try to manipulate the entire tree structure like Morris does: I wanted to be very subtle, with the data structure resembling the original tree (though, with backward pointers). The key issue I hit? Going Backward. Once I’m done visiting the branches of a node, I need to go back to the parent (to which I have a pointer too), and restore the structure. But HOW am I going to reconstruct the tree? How do I know if the Branch I just visited was the left or the right branch of the parent I want to move back to? Downsize the problem In a general Binary Tree, there is no guarantee of the order and distribution of nodes. It’s just a tree where every node has 0, 1 or 2 child nodes. I didn’t have any “rule” on which to build a backward-restoring logic. But then I had an idea: what about BSTs (Binary Search Tree)? In those trees, there is a strong order relationship between a node and its childs. This means that at any moment in time, once I’m done visiting a branch, I can reconstruct where I’m coming from, looking at the values of the parent and the child: parent-&gt;value &gt; child-&gt;value ? is_left_child : is_right_child And, so I wrote the De Marino BST Post-Order Traversal algorithm: void de_marino_bst_post_order_traversal(node *root) { node *curr = root; //&lt; current node node *par = NULL; //&lt; parent of current node node *next = root; //&lt; next node to traversal (but sometimes, just temp variable) int dir = DOWN; //&lt; direction in which we are moving do { if (dir == DOWN &amp;&amp; curr-&gt;left != NULL) { // Go down left next = curr-&gt;left; curr-&gt;left = par; par = curr; curr = next; } else if (dir == DOWN &amp;&amp; curr-&gt;right != NULL) { // Go down right next = curr-&gt;right; curr-&gt;right = par; par = curr; curr = next; } else { printf(&quot;%d\\n&quot;, curr != NULL ? curr-&gt;value : -1); if (par-&gt;value &gt; curr-&gt;value &amp;&amp; par-&gt;right != NULL) { // Go down right, coming from left // NOTE: order gives us a hint about where we come from dir = DOWN; next = par-&gt;left; // hold the way back par-&gt;left = curr; curr = par-&gt;right; par-&gt;right = next; // store the way back in the right child of par now next = curr; } else { dir = UP; if (par-&gt;value &gt; curr-&gt;value) { // Go up, coming from left // NOTE: order gives us a hint about where we come from next = par-&gt;left; par-&gt;left = curr; } else { // Go up, coming from right // NOTE: order gives us a hint about where we come from next = par-&gt;right; par-&gt;right = curr; } curr = par; par = next; } } } while(next != NULL &amp;&amp; par != NULL); printf(&quot;%d\\n&quot;, curr != NULL ? curr-&gt;value : -1); } Now, I’m almost 100% sure that I’m not the first one to stumble into something like this, but for now I’m unable to find anything in literature - cough … Google … cough . An advantage over Morris Yes, this algorithm requires the strong condition of BST while Morris works with any Binary Tree. That’s a given. But this algorithm is also faster: it doesn’t go deep into the tree to find the rightmost left child of a node, like Morris. From a quick look the computation is linear - O(n): every node is visited only once. But maybe I’m overlooking something in Morris. Far from perfect I’m also sure that this algorithm is far from bug-less: I have spent on it less than 24h between coding and thinking. So, please, to all the Computer Scientists people out there: let me know your thoughts and critics. This is a great way to spend some of that theory that we have in our heads. I have added this code to my coding exercises repo on GitHub, if you want to try it out (check latest commits). Now, as I expect, feel free to ignore my warnings and start your opinionated trashing - I’m pretty confident I’d deserve it. :)","headline":"BST traversal without stack or recursion (?)","mainEntityOfPage":{"@type":"WebPage","@id":"https://ivandemarino.me/2012/08/06/BST-traversal-wihtout-stack-or-recursion"},"url":"https://ivandemarino.me/2012/08/06/BST-traversal-wihtout-stack-or-recursion"}</script>
<!-- End Jekyll SEO tag -->

    </head>

    <body>
        <div id="layout" class="pure-g-r">

            <div id="sidebar" class="pure-u">
                <a id="toggle-navigation" href="#"><i class="icon-reorder"></i></a>

                <header id="header">

                    <hgroup>
                        <h1><a href="https://ivandemarino.me/">Too much <strong>coffee</strong><br/>too little <strong>time</strong></a></h1>
                        <h2>Ivan <strong>De Marino</strong></h2>
                    </hgroup>

                    <nav id="navigation">
                        
                            <ul id="internal-links">
                                
                                    <li class=""><a href="https://ivandemarino.me/">blog</a></li>
                                
                                    <li class=""><a href="https://ivandemarino.me/projects">projects</a></li>
                                
                                    <li class=""><a href="https://ivandemarino.me/about-me">about me</a></li>
                                
                                    <li class=""><a href="https://ivandemarino.me/archive">archive</a></li>
                                
                            </ul>
                        

                        
                            <ul id="rel-me-links">
                                
                                    <li><a rel="me" href="https://twitter.com/detronizator" target="_blank"><i class="icon-twitter"></i></a></li>
                                
                                    <li><a rel="me" href="https://github.com/detro" target="_blank"><i class="icon-github"></i></a></li>
                                
                                    <li><a rel="me" href="https://linkedin.com/in/ivandemarino" target="_blank"><i class="icon-linkedin"></i></a></li>
                                
                                    <li><a rel="me" href="https://ivandemarino.me/atom.xml" target="_blank"><i class="icon-rss"></i></a></li>
                                
                                    <li><a rel="me" href="https://ivandemarino.me/sitemap.xml" target="_blank"><i class="icon-sitemap"></i></a></li>
                                
                            </ul>
                        
                    </nav>

                </header>
            </div>

            <div id="main" class="pure-u-1">

                <div id="content">
                    
<article class="entry full pure-u-1">
    <header>
        <h1 class="title">
            
                BST traversal without stack or recursion (?)
            
        </h1>
        
            <ul class="meta">
                
                    <li>
                        <i class="icon-calendar"></i>
                        <time datetime="2012-08-06">Monday, 06 Aug 2012</time>
                    </li>
                

                
                    <li>
                        <i class="icon-tags"></i>
                        recursion &bull; de marino &bull; tree &bull; traversal &bull; queue &bull; morris &bull; stack
                    </li>
                

                
                    <li>
                        <i class="icon-time"></i>
                        911 words
                    </li>
                
            </ul>
        
    </header>
    
        <div class="body">
            
                <p><strong>SPOILER</strong>: <em>this article assumes quite a lot of things about your knowledge of binary trees and data structure. I won’t spend much time introducing concepts. Deal with it.</em></p>

<p>Some time ago I had the pleasure to meet with <a href="http://chrislord.net/blog/">Chris Lord</a>, who introduced me to the concept of Binary Tree Traversal without using neither a stack/queue or recursion.</p>

<p>The list of requirements that such algorithm has to fulfil:</p>

<ul>
  <li>Constant Space: no extra data structure to do the traversal</li>
  <li>Non-destructive: once finished, the tree needs to be exactly how it was before the visit</li>
</ul>

<p>Sounded <em>crazy</em> initially, but than I looked into it more deeply and discovered, thanks to some pointers from <a href="http://twitter.com/lucabox">Luca Colantonio</a>, that there is an algorithm <em>in literature</em> that does just that: <strong>Morris In-Order</strong> Traversal.</p>

<p>Morris does just that - and a very good description of how it works can be found <a href="http://stackoverflow.com/a/5506601/1389112">on Stack Overflow</a>. I suggest you have a good read and come back: pointless of me to repeat it here.</p>

<p>…</p>

<p>You back? Great!</p>

<p>So, before “discovering” the Morris algorithm, I was trying to write a solution myself. My basic idea was to:</p>

<ol>
  <li>Move downwards</li>
  <li>Manipulate pointers to the branch we are about to explore, to point backward so we have “a way back”</li>
  <li>Restore once done with that branch</li>
</ol>

<p>At that stage, it had not occur to me to try to manipulate the entire tree structure like Morris does: I wanted to be very subtle, with the data structure resembling the original tree (though, with backward pointers).</p>

<p>The key issue I hit? <strong>Going Backward</strong>. Once I’m done visiting the branches of a node, I need to go back to the parent (to which I have a pointer too), and restore the structure.</p>

<p><strong>But HOW am I going to reconstruct the tree?</strong> How do I know if the Branch I just visited was the <em>left</em> or the <em>right</em> branch of the parent I want to move back to?</p>

<h2 id="downsize-the-problem">Downsize the problem</h2>

<p>In a general Binary Tree, there is no guarantee of the order and distribution of nodes. It’s just a tree where every node has 0, 1 or 2 child nodes. I didn’t have any “rule” on which to <strong>build a backward-restoring logic</strong>.</p>

<p>But then I had an idea: what about <a href="http://en.wikipedia.org/wiki/Binary_search_tree">BSTs (Binary Search Tree)</a>? In those trees, there is a strong order relationship between a node and its childs.</p>

<p>This means that at any moment in time, once I’m done visiting a branch, I can reconstruct <em>where I’m coming from</em>, looking at the values of the parent and the child:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>parent-&gt;value &gt; child-&gt;value ? is_left_child : is_right_child
</code></pre></div></div>

<p>And, so I wrote the <strong>De Marino BST Post-Order Traversal</strong> algorithm:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">de_marino_bst_post_order_traversal</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">node</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>  <span class="c1">//&lt; current node</span>
    <span class="n">node</span> <span class="o">*</span><span class="n">par</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>   <span class="c1">//&lt; parent of current node</span>
    <span class="n">node</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>  <span class="c1">//&lt; next node to traversal (but sometimes, just temp variable)</span>
    <span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">DOWN</span><span class="p">;</span>     <span class="c1">//&lt; direction in which we are moving</span>

    <span class="k">do</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DOWN</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Go down left</span>
            <span class="n">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
            <span class="n">curr</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">par</span><span class="p">;</span>
            <span class="n">par</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DOWN</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Go down right</span>
            <span class="n">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
            <span class="n">curr</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">par</span><span class="p">;</span>
            <span class="n">par</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">curr</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">par</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="n">par</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Go down right, coming from left</span>
                <span class="c1">// NOTE: order gives us a hint about where we come from</span>
                <span class="n">dir</span> <span class="o">=</span> <span class="n">DOWN</span><span class="p">;</span>

                <span class="n">next</span> <span class="o">=</span> <span class="n">par</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>   <span class="c1">// hold the way back</span>
                <span class="n">par</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">par</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
                <span class="n">par</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>  <span class="c1">// store the way back in the right child of par now</span>
                <span class="n">next</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">dir</span> <span class="o">=</span> <span class="n">UP</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">par</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// Go up, coming from left</span>
                    <span class="c1">// NOTE: order gives us a hint about where we come from</span>
                    <span class="n">next</span> <span class="o">=</span> <span class="n">par</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
                    <span class="n">par</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="c1">// Go up, coming from right</span>
                    <span class="c1">// NOTE: order gives us a hint about where we come from</span>
                    <span class="n">next</span> <span class="o">=</span> <span class="n">par</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
                    <span class="n">par</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">par</span><span class="p">;</span>
                <span class="n">par</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">par</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">curr</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now, I’m almost 100% sure that I’m not the first one to <em>stumble</em> into something like this, but for now I’m unable to find anything in literature - <em>cough</em> … Google … <em>cough</em> .</p>

<h2 id="an-advantage-over-morris">An advantage over Morris</h2>

<p>Yes, this algorithm requires the <strong>strong condition of BST</strong> while Morris works with any Binary Tree. That’s a given. But this algorithm is also <strong>faster</strong>: it doesn’t go deep into the tree to find the rightmost left child of a node, like Morris. From a quick look <strong>the computation is linear - O(n)</strong>: every node is visited only once. But maybe I’m overlooking something in Morris.</p>

<h2 id="far-from-perfect">Far from perfect</h2>

<p>I’m also sure that this algorithm is <strong>far from bug-less</strong>: I have spent on it less than 24h between coding and thinking. So, please, to all the Computer Scientists people out there: let me know your thoughts and critics. This is a great way to spend some of that theory that we have in our heads.</p>

<p>I have added this code to my <a href="https://github.com/detro/coding-exercises/commits/master">coding exercises</a> repo on GitHub, if you want to try it out (check latest commits).</p>

<p>Now, as I expect, feel free to ignore my warnings and start your opinionated trashing - I’m pretty confident I’d deserve it. :)</p>

            
        </div>
    
</article>


                </div>

                <footer id="footer">
                    
                        <span>Hosted on <a href="http://pages.github.com/" target="_blank">GitHub Pages</a></span>
                    
                    
                        <span>Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a></span>
                    
                    
                    
                        <span>Licensed under <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">CC BY 4.0</a></span>
                    
                </footer>

            </div>
        </div>

        <script>
            // Registering "click" handler for "#toggle-navigation"
            normalize.elementAddEventListener(document.getElementById("toggle-navigation"),
                "click",
                function(e) {
                    var navEl = document.getElementById("navigation");
                    navEl.classList.toggle("open");
                    e.preventDefault();
                });
        </script>
    </body>
</html>
