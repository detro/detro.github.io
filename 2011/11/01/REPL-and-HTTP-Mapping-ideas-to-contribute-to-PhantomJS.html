<!DOCTYPE html>
<html>
    <head>
        <link rel="icon" href="favicon.ico" type="image/x-icon">
        <link type="application/atom+xml" rel="alternate" href="http://ivandemarino.me/atom.xml" title="Too much coffee, too little time" />

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

        <!-- Third Party CSS -->
        <link href="/css/thirdparty/purecss-combo.min.css" rel="stylesheet">
        <link href="/css/thirdparty/font-awesome/css/font-awesome.min.css" rel="stylesheet">
        <!--[if IE 7]>
            <link href="/css/thirdparty/font-awesome/css/font-awesome-ie7.min.css" rel="stylesheet" >
        <![endif]-->

        <!-- Theme CSS -->
        <link rel="stylesheet" href="/css/leo.css">

        <!-- Utility JS -->
        <script type="text/javascript" src="/js/normalize.js"></script>

        
            <script async src="https://www.googletagmanager.com/gtag/js?id=UA-136869-11"></script>
            <script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());

              gtag('config', 'UA-136869-11');
            </script>
        

        
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-K0JQTBH0J9"></script>
            <script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());

              gtag('config', 'G-K0JQTBH0J9');
            </script>
        

        <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>REPL and HTTP Mapping: ideas to contribute to PhantomJS | Too much coffee, too little time</title>
<meta name="generator" content="Jekyll v4.3.1" />
<meta property="og:title" content="REPL and HTTP Mapping: ideas to contribute to PhantomJS" />
<meta name="author" content="detro" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Recently, I’m donating my spare time to the amazing Stanford Online AI Class, and writing down notes takes time. But I’m still working, in the spare time of the spare time, on PhantomJS. Yes, very slowly, but I’m not stall. Recently two ideas have come to mind, and it’s stuff I’d love to see supported by PhantomJS. REPL From the Wikipedia article: A read–eval–print loop (REPL), also known as an interactive toplevel, is a simple, interactive computer programming environment. [...] In a REPL, the user may enter expressions, which are then evaluated, and the results displayed. What I really like of the REPL, is the idea of launching it and start typing code into it straightaway. No files to create, save and launch. It’s very good when you want to quickly toy with a concept/idea, and it’s so small it doesn’t really deserves a dedicated script file for that. I haven’t finished it yet, but I published my current status on this branch. Check it out! Also, the REPL is truly enabling an even more simple concept: controlling PhantomJS by just piping commands to it through the STD_IN. A key aspect to enable easier integration of PhantomJS in larger stacks. In facts, I discovered that sgentle has started working on wrapping PhantomJS into a Node module, and released phantomjs-node. What struck me is how he had to work out a communication channel between Node and the instances of PhantomJS: he opted for Socket.io. Socket.io is definitely a smart solution, but phantom is launched as a child process: there must be a better way to let Node and PhantomJS speak, instead of having to pass through the network stack. Right? And that’s where my work on the REPL (and in general into controlling PhantomJS via STD_IN) comes into the picture. HTTP Mapping In our effort to build proper Javascript Testing into Betfair’s new platform, a problem arises: how do we mock effectively and easily the service data responses that our code consumes? Javascript, as many of you know, is not easy to test: it normally requires you to run your full stack to be able to test it fairly. But we are not giving up, and want to find a solution to be able to test our code, without having to run an entire infrastructure of services, particularly while code is actually developed. The developer has to be able to work into this loop: type save run test So, here is the idea: what if we could intercept all those HTTP/XHR calls that the Javascript in the page does, and Map them to local files (or even different remotes)? PhantomJS source code is already structured to abstract the network access of the WebPage through a NetworkAccessManager. At the moment we are using it for monitoring and sniffing. I want to add a functionality to the webpage module so that given a file httpmap.json that looks like:" />
<meta property="og:description" content="Recently, I’m donating my spare time to the amazing Stanford Online AI Class, and writing down notes takes time. But I’m still working, in the spare time of the spare time, on PhantomJS. Yes, very slowly, but I’m not stall. Recently two ideas have come to mind, and it’s stuff I’d love to see supported by PhantomJS. REPL From the Wikipedia article: A read–eval–print loop (REPL), also known as an interactive toplevel, is a simple, interactive computer programming environment. [...] In a REPL, the user may enter expressions, which are then evaluated, and the results displayed. What I really like of the REPL, is the idea of launching it and start typing code into it straightaway. No files to create, save and launch. It’s very good when you want to quickly toy with a concept/idea, and it’s so small it doesn’t really deserves a dedicated script file for that. I haven’t finished it yet, but I published my current status on this branch. Check it out! Also, the REPL is truly enabling an even more simple concept: controlling PhantomJS by just piping commands to it through the STD_IN. A key aspect to enable easier integration of PhantomJS in larger stacks. In facts, I discovered that sgentle has started working on wrapping PhantomJS into a Node module, and released phantomjs-node. What struck me is how he had to work out a communication channel between Node and the instances of PhantomJS: he opted for Socket.io. Socket.io is definitely a smart solution, but phantom is launched as a child process: there must be a better way to let Node and PhantomJS speak, instead of having to pass through the network stack. Right? And that’s where my work on the REPL (and in general into controlling PhantomJS via STD_IN) comes into the picture. HTTP Mapping In our effort to build proper Javascript Testing into Betfair’s new platform, a problem arises: how do we mock effectively and easily the service data responses that our code consumes? Javascript, as many of you know, is not easy to test: it normally requires you to run your full stack to be able to test it fairly. But we are not giving up, and want to find a solution to be able to test our code, without having to run an entire infrastructure of services, particularly while code is actually developed. The developer has to be able to work into this loop: type save run test So, here is the idea: what if we could intercept all those HTTP/XHR calls that the Javascript in the page does, and Map them to local files (or even different remotes)? PhantomJS source code is already structured to abstract the network access of the WebPage through a NetworkAccessManager. At the moment we are using it for monitoring and sniffing. I want to add a functionality to the webpage module so that given a file httpmap.json that looks like:" />
<link rel="canonical" href="http://ivandemarino.me/2011/11/01/REPL-and-HTTP-Mapping-ideas-to-contribute-to-PhantomJS" />
<meta property="og:url" content="http://ivandemarino.me/2011/11/01/REPL-and-HTTP-Mapping-ideas-to-contribute-to-PhantomJS" />
<meta property="og:site_name" content="Too much coffee, too little time" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2011-11-01T00:11:47+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="REPL and HTTP Mapping: ideas to contribute to PhantomJS" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"detro"},"dateModified":"2011-11-01T00:11:47+00:00","datePublished":"2011-11-01T00:11:47+00:00","description":"Recently, I’m donating my spare time to the amazing Stanford Online AI Class, and writing down notes takes time. But I’m still working, in the spare time of the spare time, on PhantomJS. Yes, very slowly, but I’m not stall. Recently two ideas have come to mind, and it’s stuff I’d love to see supported by PhantomJS. REPL From the Wikipedia article: A read–eval–print loop (REPL), also known as an interactive toplevel, is a simple, interactive computer programming environment. [...] In a REPL, the user may enter expressions, which are then evaluated, and the results displayed. What I really like of the REPL, is the idea of launching it and start typing code into it straightaway. No files to create, save and launch. It’s very good when you want to quickly toy with a concept/idea, and it’s so small it doesn’t really deserves a dedicated script file for that. I haven’t finished it yet, but I published my current status on this branch. Check it out! Also, the REPL is truly enabling an even more simple concept: controlling PhantomJS by just piping commands to it through the STD_IN. A key aspect to enable easier integration of PhantomJS in larger stacks. In facts, I discovered that sgentle has started working on wrapping PhantomJS into a Node module, and released phantomjs-node. What struck me is how he had to work out a communication channel between Node and the instances of PhantomJS: he opted for Socket.io. Socket.io is definitely a smart solution, but phantom is launched as a child process: there must be a better way to let Node and PhantomJS speak, instead of having to pass through the network stack. Right? And that’s where my work on the REPL (and in general into controlling PhantomJS via STD_IN) comes into the picture. HTTP Mapping In our effort to build proper Javascript Testing into Betfair’s new platform, a problem arises: how do we mock effectively and easily the service data responses that our code consumes? Javascript, as many of you know, is not easy to test: it normally requires you to run your full stack to be able to test it fairly. But we are not giving up, and want to find a solution to be able to test our code, without having to run an entire infrastructure of services, particularly while code is actually developed. The developer has to be able to work into this loop: type save run test So, here is the idea: what if we could intercept all those HTTP/XHR calls that the Javascript in the page does, and Map them to local files (or even different remotes)? PhantomJS source code is already structured to abstract the network access of the WebPage through a NetworkAccessManager. At the moment we are using it for monitoring and sniffing. I want to add a functionality to the webpage module so that given a file httpmap.json that looks like:","headline":"REPL and HTTP Mapping: ideas to contribute to PhantomJS","mainEntityOfPage":{"@type":"WebPage","@id":"http://ivandemarino.me/2011/11/01/REPL-and-HTTP-Mapping-ideas-to-contribute-to-PhantomJS"},"url":"http://ivandemarino.me/2011/11/01/REPL-and-HTTP-Mapping-ideas-to-contribute-to-PhantomJS"}</script>
<!-- End Jekyll SEO tag -->

    </head>

    <body>
        <div id="layout" class="pure-g-r">

            <div id="sidebar" class="pure-u">
                <a id="toggle-navigation" href="#"><i class="icon-reorder"></i></a>

                <header id="header">

                    <hgroup>
                        <h1><a href="http://ivandemarino.me/">Too much <strong>coffee</strong><br/>too little <strong>time</strong></a></h1>
                        <h2>Ivan <strong>De Marino</strong></h2>
                    </hgroup>

                    <nav id="navigation">
                        
                            <ul id="internal-links">
                                
                                    <li class=""><a href="http://ivandemarino.me/">blog</a></li>
                                
                                    <li class=""><a href="http://ivandemarino.me/projects">projects</a></li>
                                
                                    <li class=""><a href="http://ivandemarino.me/about-me">about me</a></li>
                                
                                    <li class=""><a href="http://ivandemarino.me/archive">archive</a></li>
                                
                            </ul>
                        

                        
                            <ul id="rel-me-links">
                                
                                    <li><a rel="me" href="https://twitter.com/detronizator" target="_blank"><i class="icon-twitter"></i></a></li>
                                
                                    <li><a rel="me" href="https://github.com/detro" target="_blank"><i class="icon-github"></i></a></li>
                                
                                    <li><a rel="me" href="http://linkedin.com/in/ivandemarino" target="_blank"><i class="icon-linkedin"></i></a></li>
                                
                                    <li><a rel="me" href="http://ivandemarino.me/atom.xml" target="_blank"><i class="icon-rss"></i></a></li>
                                
                                    <li><a rel="me" href="http://ivandemarino.me/sitemap.xml" target="_blank"><i class="icon-sitemap"></i></a></li>
                                
                            </ul>
                        
                    </nav>

                </header>
            </div>

            <div id="main" class="pure-u-1">

                <div id="content">
                    
<article class="entry full pure-u-1">
    <header>
        <h1 class="title">
            
                REPL and HTTP Mapping: ideas to contribute to PhantomJS
            
        </h1>
        
            <ul class="meta">
                
                    <li>
                        <i class="icon-calendar"></i>
                        <time datetime="2011-11-01">Tuesday, 01 Nov 2011</time>
                    </li>
                

                
                    <li>
                        <i class="icon-tags"></i>
                        node &bull; http &bull; phantomjs &bull; stdin &bull; mapping &bull; idea &bull; repl &bull; contribution
                    </li>
                

                
                    <li>
                        <i class="icon-time"></i>
                        640 words
                    </li>
                
            </ul>
        
    </header>
    
        <div class="body">
            
                <p>Recently, I’m donating my spare time to the amazing <a href="http://www.ai-class.com">Stanford Online AI Class</a>, and writing down <a href="http://blog.ivandemarino.me/tag/notes">notes</a> takes time.</p>

<p>But I’m still working, in the spare time of the spare time, on <a href="http://www.phantomjs.org/">PhantomJS</a>. Yes, very slowly, but I’m not stall.</p>

<p>Recently two ideas have come to mind, and it’s stuff I’d love to see supported by PhantomJS.</p>

<h2 id="repl">REPL</h2>

<p>From <a href="http://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">the Wikipedia article</a>:</p>
<blockquote>
A read–eval–print loop (REPL), also known as an interactive toplevel, is a simple, interactive computer programming environment.

[...]

In a REPL, the user may enter expressions, which are then evaluated, and the results displayed.
</blockquote>

<p>What I really like of the REPL, is the idea of launching it and start typing code into it straightaway. No files to create, save and launch. It’s very good when you want to quickly toy with a concept/idea, and it’s so small it doesn’t really <em>deserves</em> a dedicated script file for that.</p>

<p>I haven’t finished it yet, but I published my current status on <a href="https://github.com/detro/phantomjs/tree/dev-repl2">this branch</a>. Check it out!</p>

<p>Also, the REPL is truly enabling an even more simple concept: controlling PhantomJS by just piping commands to it through the <a href="http://en.wikipedia.org/wiki/Standard_streams">STD_IN</a>. A <strong>key</strong> aspect to enable easier integration of PhantomJS in larger stacks.</p>

<p>In facts, I discovered that <a href="https://github.com/sgentle">sgentle</a> has started working on wrapping PhantomJS into a Node module, and released <a href="https://github.com/sgentle/phantomjs-node">phantomjs-node</a>. What struck me is how he had to work out a <em>communication channel</em> between <a href="http://nodejs.org/">Node</a> and the instances of PhantomJS: he opted for <a href="http://socket.io/">Socket.io</a>.</p>

<p>Socket.io is definitely a <em>smart</em> solution, but phantom is launched as a child process: there must be a better way to let Node and PhantomJS speak, instead of having to pass through the network stack. Right?</p>

<p>And that’s where my work on the REPL (and in general into controlling PhantomJS via STD_IN) comes into the picture.</p>

<h2 id="http-mapping">HTTP Mapping</h2>

<p>In our effort to build proper Javascript Testing into <a href="http://beta.betfair.com">Betfair’s new platform</a>, a problem arises: how do we mock <em>effectively</em> and <em>easily</em> the service data responses that our code consumes?</p>

<p>Javascript, as many of you know, is not <em>easy to test</em>: it normally requires you to run your full stack to be able to test it <em>fairly</em>. But we are not giving up, and want to find a solution to be able to test our code, without having to run an entire infrastructure of services, particularly while code is actually developed. The developer has to be able to <em>work into this loop</em>:</p>

<ol>
  <li>type</li>
  <li>save</li>
  <li>run test</li>
</ol>

<p>So, here is the idea: <em>what if we could intercept all those HTTP/XHR calls that the Javascript in the page does, and Map them to local files (or even different remotes)?</em></p>

<p>PhantomJS source code is already structured to abstract the network access of the <a href="http://doc.qt.nokia.com/4.7/qwebpage.html">WebPage</a> through a <a href="http://doc.qt.nokia.com/4.7/qnetworkaccessmanager.html">NetworkAccessManager</a>. At the moment we are using it for monitoring and sniffing.</p>

<p>I want to add a functionality to the <code class="language-plaintext highlighter-rouge">webpage</code> module so that given a file <code class="language-plaintext highlighter-rouge">httpmap.json</code> that looks like:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="w">
     </span><span class="p">{</span><span class="w">
          </span><span class="nl">"method"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"GET"</span><span class="p">,</span><span class="w"> </span><span class="s2">"POST"</span><span class="p">],</span><span class="w">
          </span><span class="nl">"source"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"http://*.betfair.com/bla/*/test"</span><span class="p">,</span><span class="w">
          </span><span class="nl">"destination"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"local_file.json"</span><span class="w">
     </span><span class="p">},</span><span class="w">
     </span><span class="p">{</span><span class="w">
          </span><span class="nl">"method"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"GET"</span><span class="p">,</span><span class="w">
          </span><span class="nl">"source"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"http://*.betfair.com/bla/*/api"</span><span class="p">,</span><span class="w">
          </span><span class="nl">"destination"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
               </span><span class="s2">"1_local_file.json"</span><span class="p">,</span><span class="w">
               </span><span class="s2">"2_local_file.json"</span><span class="p">,</span><span class="w">
               </span><span class="s2">"http://testapi.example.com/bla/api/test"</span><span class="w">
          </span><span class="p">]</span><span class="w">
     </span><span class="p">}</span><span class="w">
</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>a tester that uses phantom could do something like:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span><span class="p">),</span>
    <span class="nx">page</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">webpage</span><span class="dl">'</span><span class="p">).</span><span class="nx">create</span><span class="p">(),</span>
    <span class="nx">HTTP_MAP</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">httpmap.json</span><span class="dl">"</span><span class="p">;</span>

<span class="nx">page</span><span class="p">.</span><span class="nx">setHttpMap</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">read</span><span class="p">(</span><span class="nx">HTTP_MAP</span><span class="p">));</span>

<span class="c1">// ... do stuff with page, while the HTTP requests are mapped</span>
</code></pre></div></div>

<p>As you can probably guess, the format of the map offers some extra nifty features:</p>

<ul>
  <li>the <code class="language-plaintext highlighter-rouge">method</code> field can be single (a <code class="language-plaintext highlighter-rouge">string</code>) or multiple (an array of <code class="language-plaintext highlighter-rouge">string</code>)</li>
  <li>the <code class="language-plaintext highlighter-rouge">destination</code> field can be a single url (a <code class="language-plaintext highlighter-rouge">string</code>), or multiple destinations (an array of <code class="language-plaintext highlighter-rouge">string</code>) that phantom will cycle through at every matching request</li>
  <li>the <code class="language-plaintext highlighter-rouge">source</code> field accepts <a href="http://en.wikipedia.org/wiki/Regular_expression">regexp</a>, and I’m thinking to add variables</li>
</ul>

<h2 id="help">Help</h2>

<p>This are my ideas so far. It would be of GREAT help if you, PhantomJS lover, could spend sometime to review those and suggest accordingly.</p>

<p><strong>Happy Testing!</strong></p>

            
        </div>
    
</article>


                </div>

                <footer id="footer">
                    
                        <span>Hosted on <a href="http://pages.github.com/" target="_blank">GitHub Pages</a></span>
                    
                    
                        <span>Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a></span>
                    
                    
                    
                        <span>Licensed under <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">CC BY 4.0</a></span>
                    
                </footer>

            </div>
        </div>

        <script>
            // Registering "click" handler for "#toggle-navigation"
            normalize.elementAddEventListener(document.getElementById("toggle-navigation"),
                "click",
                function(e) {
                    var navEl = document.getElementById("navigation");
                    navEl.classList.toggle("open");
                    e.preventDefault();
                });
        </script>
    </body>
</html>
